{
  "version": 3,
  "sources": ["../esm/from.js"],
  "sourcesContent": ["import {\n  realpathSync,\n  statSync,\n  rmdirSync,\n  createReadStream,\n  promises as fs\n} from 'node:fs'\nimport { basename, sep, join } from 'node:path'\nimport { tmpdir } from 'node:os'\nimport process from 'node:process'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat, mkdtemp } = fs\nlet i = 0, tempDir, registry\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * Creates a temporary blob backed by the filesystem.\n * NOTE: requires node.js v14 or higher to use FinalizationRegistry\n *\n * @param {*} data Same as fs.writeFile data\n * @param {BlobPropertyBag & {signal?: AbortSignal}} options\n * @param {AbortSignal} [signal] in case you wish to cancel the write operation\n * @returns {Promise<Blob>}\n */\nconst createTemporaryBlob = async (data, {signal, type} = {}) => {\n  registry = registry || new FinalizationRegistry(fs.unlink)\n  tempDir = tempDir || await mkdtemp(realpathSync(tmpdir()) + sep)\n  const id = `${i++}`\n  const destination = join(tempDir, id)\n  if (data instanceof ArrayBuffer) data = new Uint8Array(data)\n  await fs.writeFile(destination, data, { signal })\n  const blob = await blobFrom(destination, type)\n  registry.register(blob, destination)\n  return blob\n}\n\n/**\n * Creates a temporary File backed by the filesystem.\n * Pretty much the same as constructing a new File(data, name, options)\n *\n * NOTE: requires node.js v14 or higher to use FinalizationRegistry\n * @param {*} data\n * @param {string} name\n * @param {FilePropertyBag & {signal?: AbortSignal}} opts\n * @returns {Promise<File>}\n */\nconst createTemporaryFile = async (data, name, opts) => {\n  const blob = await createTemporaryBlob(data)\n  return new File([blob], name, opts)\n}\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n    this.originalSize = options.originalSize === undefined\n      ? options.size\n      : options.originalSize\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      originalSize: this.originalSize,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs, size } = await stat(this.#path)\n\n    if (mtimeMs > this.lastModified || this.originalSize !== size) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nprocess.once('exit', () => {\n  tempDir && rmdirSync(tempDir, { recursive: true })\n})\n\nexport default blobFromSync\nexport {\n  Blob,\n  blobFrom,\n  blobFromSync,\n  createTemporaryBlob,\n  File,\n  fileFrom,\n  fileFromSync,\n  createTemporaryFile\n}"],
  "mappings": "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",
  "names": ["Blob", "File", "fs", "stat", "Blob", "File", "DOMException", "process"]
}
